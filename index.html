<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>Simple GL Shader Test</title>
        <meta charset="UTF-8">
        <link rel="stylesheet" href="style.css">
        <script src="js/three.js"></script>
        <script src="js/Detector.js"></script>
        
        <script src="js/Projector.js"></script>
        <script src="js/CanvasRenderer.js"></script>
        
        <script src="js/dwin/main.js"></script>
        <script src="js/dwin/logging.js"></script>
        
        <script src="js/dwin/shaders/vertexShader.js"></script>
        <script src="js/dwin/shaders/demoFragmentShader1.js"></script>
        <script src="js/dwin/shaders/fragmentShader1.js"></script>
        <script src="js/dwin/shaders/fragmentShader2.js"></script>
        <script src="js/dwin/shaders/randomNumberGeneratorFragmentShader.js"></script>
        
        <script src="js/vibornoff/asmcrypto.js"></script>
        
    </head>
    <body>
        <script>
            if (!window.WebGLRenderingContext) {
                window.alert("WebGL isn't supported by your browser!");
                console.log("WebGL isn't supported by your browser!");
            }
        </script>
        <script>
            
        init();
        
        var chunk = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus in risus non augue vestibulum semper. Nullam feugiat tortor sit amet dolor venenatis ultricies. Class aptent taciti sociosqu ad litora torquent per conubia nostra, per inceptos himenaeos. Pellentesque imperdiet ullamcorper ullamcorper. Aliquam eget nunc a diam dapibus ultricies. In hac habitasse platea dictumst. Curabitur nec tortor nibh, fermentum molestie massa. Vestibulum volutpat gravida nisl, vitae viverra eros bibendum a. Vestibulum sed felis arcu, et volutpat leo. Praesent semper, nibh et suscipit auctor, magna enim lacinia diam, id tristique arcu nunc at odio. Nunc vitae est risus, nec placerat velit. Ut rutrum fringilla consectetur. Fusce rutrum dui aliquet ligula suscipit aliquam. Mauris tincidunt, lacus ut suscipit sodales, justo magna accumsan justo, id tristique massa odio semper enim.';
		var numTests = 10;
        
        
        function start() {
            startTime = new Date();
                      
            create();
            render();
            addToConsole("Time Taken = " + (endTime - startTime) + "ms");
        }
		
		function WebCryptoAESCBCTest(bitSize, curTest)
        {
			var WebCryptoAESCBCTest_EncryptionTime = 0;
			var WebCryptoAESCBCTest_DecryptionTime = 0;
			function finishedWebCryptoAESCBCTest(bitSize)
			{
				addToConsole("WebCrypto-AES-CBC-"+bitSize+"-Encryption" + " = " + (WebCryptoAESCBCTest_EncryptionTime/numTests) + "ms");
				addToConsole("WebCrypto-AES-CBC-"+bitSize+"-Decryption" + " = " + (WebCryptoAESCBCTest_DecryptionTime/numTests) + "ms");
			}
            var bs = 1024 * 1024;
            var str = '';
            while ( str.length < bs ) str += chunk;
            str = str.substr( 0, bs );

            var buf = new Uint8Array(bs);
            for ( var i = 0; i < bs; i++ ) buf[i] = str.charCodeAt(i);
			
			window.crypto.subtle.generateKey(
				{
					name: "AES-CBC",
					length: bitSize, //can be  128, 192, or 256
				},
				false, //whether the key is extractable (i.e. can be used in exportKey)
				["encrypt", "decrypt"] //can "encrypt", "decrypt", "wrapKey", or "unwrapKey"
			).then(function(aesKey){
				
				var startTime = new Date();
				var cipherText;
				var iV = window.crypto.getRandomValues(new Uint8Array(16));
				window.crypto.subtle.encrypt(
					{
						name: "AES-CBC",
						//Don't re-use initialization vectors!
						//Always generate a new iv every time your encrypt!
						iv: iV,
					},
					aesKey, //from generateKey or importKey above
					buf //ArrayBuffer of data you want to encrypt
				)
				.then(function(encrypted){
					//returns an ArrayBuffer containing the encrypted data
					//console.log(new Uint8Array(encrypted));
					cipherText = new Uint8Array(encrypted);
					var endTime = new Date();
					var encryptionTimeTaken = (endTime - startTime);
					
					startTime = new Date();
					window.crypto.subtle.decrypt(
						{
							name: "AES-CBC",
							iv: iV, //The initialization vector you used to encrypt
						},
						aesKey, //from generateKey or importKey above
						cipherText //ArrayBuffer of the data
					)
					.then(function(decrypted){
						//returns an ArrayBuffer containing the decrypted data
						new Uint8Array(decrypted);
						endTime = new Date();
						var decryptionTimeTaken = (endTime - startTime);

						//var cipherText = asmCrypto.AES_CBC.encrypt( str, '0123456789abcdef' ); //string
						var cipherText = asmCrypto.AES_CBC.encrypt( buf, '0123456789abcdef' ); //buffer
						var endTime = new Date();
						var encryptionTimeTaken = (endTime - startTime);
						WebCryptoAESCBCTest_EncryptionTime += encryptionTimeTaken;
						WebCryptoAESCBCTest_DecryptionTime += decryptionTimeTaken;
						if(curTest == numTests-1)
						{
							finishedWebCryptoAESCBCTest(bitSize);
						}
						//addToConsole("AES-128-ECB Encryption = " + (endTime - startTime) + "ms");
						/*return {
								"encryptionTimeTaken":encryptionTimeTaken
								,"decryptionTimeTaken":decryptionTimeTaken
						};*/
					});
				});
				
			});
        }
		
		function WebCryptoAESCTRTest(bitSize, curTest)
        {
			var WebCryptoAESCTRTest_EncryptionTime = 0;
			var WebCryptoAESCTRTest_DecryptionTime = 0;
			function finishedWebCryptoAESCTRTest(bitSize)
			{
				addToConsole("WebCrypto-AES-CTR-"+bitSize+"-Encryption" + " = " + (WebCryptoAESCTRTest_EncryptionTime/numTests) + "ms");
				addToConsole("WebCrypto-AES-CTR-"+bitSize+"-Decryption" + " = " + (WebCryptoAESCTRTest_DecryptionTime/numTests) + "ms");
			}
            var bs = 1024 * 1024;
            var str = '';
            while ( str.length < bs ) str += chunk;
            str = str.substr( 0, bs );

            var buf = new Uint8Array(bs);
            for ( var i = 0; i < bs; i++ ) buf[i] = str.charCodeAt(i);
			
			window.crypto.subtle.generateKey(
				{
					name: "AES-CTR",
					length: bitSize, //can be  128, 192, or 256
				},
				false, //whether the key is extractable (i.e. can be used in exportKey)
				["encrypt", "decrypt"] //can "encrypt", "decrypt", "wrapKey", or "unwrapKey"
			).then(function(aesKey){
				
				var startTime = new Date();
				var cipherText;
				var counterArray = new Uint8Array(16);
				window.crypto.subtle.encrypt(
					{
						name: "AES-CTR",
						//Don't re-use counters!
						//Always use a new counter every time your encrypt!
						counter: counterArray,
						length: 128, //can be 1-128
					},
					aesKey, //from generateKey or importKey above
					buf //ArrayBuffer of data you want to encrypt
				)
				.then(function(encrypted){
					//returns an ArrayBuffer containing the encrypted data
					//console.log(new Uint8Array(encrypted));
					cipherText = new Uint8Array(encrypted);
					var endTime = new Date();
					var encryptionTimeTaken = (endTime - startTime);
					
					startTime = new Date();
					window.crypto.subtle.decrypt(
						{
							name: "AES-CTR",
							counter: counterArray, //The same counter you used to encrypt
							length: 128, //The same length you used to encrypt
						},
						aesKey, //from generateKey or importKey above
						cipherText //ArrayBuffer of the data
					)
					.then(function(decrypted){
						//returns an ArrayBuffer containing the decrypted data
						new Uint8Array(decrypted);
						endTime = new Date();
						var decryptionTimeTaken = (endTime - startTime);

						//var cipherText = asmCrypto.AES_CBC.encrypt( str, '0123456789abcdef' ); //string
						var cipherText = asmCrypto.AES_CBC.encrypt( buf, '0123456789abcdef' ); //buffer
						var endTime = new Date();
						var encryptionTimeTaken = (endTime - startTime);
						WebCryptoAESCTRTest_EncryptionTime += encryptionTimeTaken;
						WebCryptoAESCTRTest_DecryptionTime += decryptionTimeTaken;
						if(curTest == numTests-1)
						{
							finishedWebCryptoAESCTRTest(bitSize);
						}
						//addToConsole("AES-128-ECB Encryption = " + (endTime - startTime) + "ms");
						/*return {
								"encryptionTimeTaken":encryptionTimeTaken
								,"decryptionTimeTaken":decryptionTimeTaken
						};*/
					});
				});
				
			});
        }
		
		function WebCryptoAESGCMTest(bitSize, curTest)
        {
			var WebCryptoAESGCMTest_EncryptionTime = 0;
			var WebCryptoAESGCMTest_DecryptionTime = 0;
			function finishedWebCryptoAESGCMTest(bitSize)
			{
				addToConsole("WebCrypto-AES-GCM-"+bitSize+"-Encryption" + " = " + (WebCryptoAESGCMTest_EncryptionTime/numTests) + "ms");
				addToConsole("WebCrypto-AES-GCM-"+bitSize+"-Decryption" + " = " + (WebCryptoAESGCMTest_DecryptionTime/numTests) + "ms");
			}
            var bs = 1024 * 1024;
            var str = '';
            while ( str.length < bs ) str += chunk;
            str = str.substr( 0, bs );

            var buf = new Uint8Array(bs);
            for ( var i = 0; i < bs; i++ ) buf[i] = str.charCodeAt(i);
			
			window.crypto.subtle.generateKey(
				{
					name: "AES-GCM",
					length: bitSize, //can be  128, 192, or 256
				},
				false, //whether the key is extractable (i.e. can be used in exportKey)
				["encrypt", "decrypt"] //can "encrypt", "decrypt", "wrapKey", or "unwrapKey"
			).then(function(aesKey){
				
				var startTime = new Date();
				var cipherText;
				var iV = window.crypto.getRandomValues(new Uint8Array(12));
				window.crypto.subtle.encrypt(
					{
						name: "AES-GCM",

						//Don't re-use initialization vectors!
						//Always generate a new iv every time your encrypt!
						//Recommended to use 12 bytes length
						iv: iV,

						//Additional authentication data (optional)

						//Tag length (optional)
						tagLength: 128, //can be 32, 64, 96, 104, 112, 120 or 128 (default)
					},
					aesKey, //from generateKey or importKey above
					buf //ArrayBuffer of data you want to encrypt
				)
				.then(function(encrypted){
					//returns an ArrayBuffer containing the encrypted data
					//console.log(new Uint8Array(encrypted));
					cipherText = new Uint8Array(encrypted);
					var endTime = new Date();
					var encryptionTimeTaken = (endTime - startTime);
					
					startTime = new Date();
					window.crypto.subtle.decrypt(
						{
							name: "AES-GCM",
							iv: iV, //The initialization vector you used to encrypt
							tagLength: 128, //The tagLength you used to encrypt (if any)
						},
						aesKey, //from generateKey or importKey above
						cipherText //ArrayBuffer of the data
					)
					.then(function(decrypted){
						//returns an ArrayBuffer containing the decrypted data
						new Uint8Array(decrypted);
						endTime = new Date();
						var decryptionTimeTaken = (endTime - startTime);

						//var cipherText = asmCrypto.AES_CBC.encrypt( str, '0123456789abcdef' ); //string
						var cipherText = asmCrypto.AES_CBC.encrypt( buf, '0123456789abcdef' ); //buffer
						var endTime = new Date();
						var encryptionTimeTaken = (endTime - startTime);
						WebCryptoAESGCMTest_EncryptionTime += encryptionTimeTaken;
						WebCryptoAESGCMTest_DecryptionTime += decryptionTimeTaken;
						if(curTest == numTests-1)
						{
							finishedWebCryptoAESGCMTest(bitSize);
						}
						//addToConsole("AES-128-ECB Encryption = " + (endTime - startTime) + "ms");
						/*return {
								"encryptionTimeTaken":encryptionTimeTaken
								,"decryptionTimeTaken":decryptionTimeTaken
						};*/
					});
				});
				
			});
        }
		
		function asmcryptoAESCTR128Test()
        {
            var bs = 1024 * 1024;
            var str = '';
            while ( str.length < bs ) str += chunk;
            str = str.substr( 0, bs );

            var buf = new Uint8Array(bs);
            for ( var i = 0; i < bs; i++ ) buf[i] = str.charCodeAt(i);
            
            var startTime = new Date();
            var cipherText = asmCrypto.AES_CTR.encrypt( buf, '0123456789abcdef'); //buffer
            var endTime = new Date();
			var encryptionTimeTaken = (endTime - startTime);
            //addToConsole("AES-128-ECB Encryption = " + (endTime - startTime) + "ms");

            startTime = new Date();
            var plainText = asmCrypto.AES_CTR.decrypt( cipherText, '0123456789abcdef');
            endTime = new Date();
			var decryptionTimeTaken = (endTime - startTime);
            //addToConsole("Decryption = " + (endTime - startTime) + "ms");
            //window.alert(asmCrypto.bytes_to_string(plainText));
			return {
					"encryptionTimeTaken":encryptionTimeTaken
					,"decryptionTimeTaken":decryptionTimeTaken
			};
        }
		
		function asmcryptoAESCTR256Test()
        {
            var bs = 1024 * 1024;
            var str = '';
            while ( str.length < bs ) str += chunk;
            str = str.substr( 0, bs );

            var buf = new Uint8Array(bs);
            for ( var i = 0; i < bs; i++ ) buf[i] = str.charCodeAt(i);
            
            var startTime = new Date();
            //var cipherText = asmCrypto.AES_CBC.encrypt( str, '0123456789abcdef' ); //string
            var cipherText = asmCrypto.AES_CTR.encrypt( buf, '0123456789abcdef0123456789abcdef', '0123456789abcdef0123456789abcdef' ); //buffer
            var endTime = new Date();
			var encryptionTimeTaken = (endTime - startTime);
            //addToConsole("AES-128-ECB Encryption = " + (endTime - startTime) + "ms");

            startTime = new Date();
            var plainText = asmCrypto.AES_CTR.decrypt( cipherText, '0123456789abcdef0123456789abcdef', '0123456789abcdef0123456789abcdef' );
            endTime = new Date();
			var decryptionTimeTaken = (endTime - startTime);
            //addToConsole("Decryption = " + (endTime - startTime) + "ms");
            //window.alert(asmCrypto.bytes_to_string(plainText));
			return {
					"encryptionTimeTaken":encryptionTimeTaken
					,"decryptionTimeTaken":decryptionTimeTaken
			};
        }
		
		function asmcryptoAESGCM128Test()
        {
            var bs = 1024 * 1024;
            var str = '';
            while ( str.length < bs ) str += chunk;
            str = str.substr( 0, bs );

            var buf = new Uint8Array(bs);
            for ( var i = 0; i < bs; i++ ) buf[i] = str.charCodeAt(i);
            
            var startTime = new Date();
            //var cipherText = asmCrypto.AES_CBC.encrypt( str, '0123456789abcdef' ); //string
            var cipherText = asmCrypto.AES_GCM.encrypt( buf, '0123456789abcdef', '0123456789abcdef' ); //buffer
            var endTime = new Date();
			var encryptionTimeTaken = (endTime - startTime);
            //addToConsole("AES-128-ECB Encryption = " + (endTime - startTime) + "ms");

            startTime = new Date();
            var plainText = asmCrypto.AES_GCM.decrypt( cipherText, '0123456789abcdef', '0123456789abcdef' );
            endTime = new Date();
			var decryptionTimeTaken = (endTime - startTime);
            //addToConsole("Decryption = " + (endTime - startTime) + "ms");
            //window.alert(asmCrypto.bytes_to_string(plainText));
			return {
					"encryptionTimeTaken":encryptionTimeTaken
					,"decryptionTimeTaken":decryptionTimeTaken
			};
        }
		
		function asmcryptoAESGCM256Test()
        {
            var bs = 1024 * 1024;
            var str = '';
            while ( str.length < bs ) str += chunk;
            str = str.substr( 0, bs );

            var buf = new Uint8Array(bs);
            for ( var i = 0; i < bs; i++ ) buf[i] = str.charCodeAt(i);
            
            var startTime = new Date();
            //var cipherText = asmCrypto.AES_CBC.encrypt( str, '0123456789abcdef' ); //string
            var cipherText = asmCrypto.AES_GCM.encrypt( buf, '0123456789abcdef0123456789abcdef', '0123456789abcdef0123456789abcdef' ); //buffer
            var endTime = new Date();
			var encryptionTimeTaken = (endTime - startTime);
            //addToConsole("AES-128-ECB Encryption = " + (endTime - startTime) + "ms");

            startTime = new Date();
            var plainText = asmCrypto.AES_GCM.decrypt( cipherText, '0123456789abcdef0123456789abcdef', '0123456789abcdef0123456789abcdef' );
            endTime = new Date();
			var decryptionTimeTaken = (endTime - startTime);
            //addToConsole("Decryption = " + (endTime - startTime) + "ms");
            //window.alert(asmCrypto.bytes_to_string(plainText));
			return {
					"encryptionTimeTaken":encryptionTimeTaken
					,"decryptionTimeTaken":decryptionTimeTaken
			};
        }
		
        function asmcryptoAES128Test()
        {
            var bs = 1024 * 1024;
            var str = '';
            while ( str.length < bs ) str += chunk;
            str = str.substr( 0, bs );

            var buf = new Uint8Array(bs);
            for ( var i = 0; i < bs; i++ ) buf[i] = str.charCodeAt(i);
            
            var startTime = new Date();
            //var cipherText = asmCrypto.AES_CBC.encrypt( str, '0123456789abcdef' ); //string
            var cipherText = asmCrypto.AES_CBC.encrypt( buf, '0123456789abcdef' ); //buffer
            var endTime = new Date();
			var encryptionTimeTaken = (endTime - startTime);
            //addToConsole("AES-128-ECB Encryption = " + (endTime - startTime) + "ms");

            startTime = new Date();
            var plainText = asmCrypto.AES_CBC.decrypt( cipherText, '0123456789abcdef' );
            endTime = new Date();
			var decryptionTimeTaken = (endTime - startTime);
            //addToConsole("Decryption = " + (endTime - startTime) + "ms");
            //window.alert(asmCrypto.bytes_to_string(plainText));
			return {
					"encryptionTimeTaken":encryptionTimeTaken
					,"decryptionTimeTaken":decryptionTimeTaken
			};
        }
        
        function asmcryptoAES256Test()
        {
			var timeTaken = [0,0];
            var bs = 1024 * 1024;
            var str = '';
            while ( str.length < bs ) str += chunk;
            str = str.substr( 0, bs );

            var buf = new Uint8Array(bs);
            for ( var i = 0; i < bs; i++ ) buf[i] = str.charCodeAt(i);
            
            
            
            var startTime = new Date();
            //var cipherText = asmCrypto.AES_CBC.encrypt( str, '0123456789abcdef0123456789abcdef' ); //string
            var cipherText = asmCrypto.AES_CBC.encrypt( buf, '0123456789abcdef0123456789abcdef' ); //buffer
            var endTime = new Date();
			var encryptionTimeTaken = (endTime - startTime);
            //addToConsole("AES-256-ECB Encryption = " + (endTime - startTime) + "ms");

            startTime = new Date();
            var plainText = asmCrypto.AES_CBC.decrypt( cipherText, '0123456789abcdef0123456789abcdef' );
            endTime = new Date();
			var decryptionTimeTaken = (endTime - startTime);
            //addToConsole("Decryption = " + (endTime - startTime) + "ms");
            //window.alert(asmCrypto.bytes_to_string(plainText));
			return {
					"encryptionTimeTaken":encryptionTimeTaken
					,"decryptionTimeTaken":decryptionTimeTaken
			};
        }
        
        var RSA2048Key;
        function asmcryptoRSA2048Test()
        {
            startTime = new Date();
            RSA2048Key = asmCrypto.RSA.generateKey(2048, 65537);
            endTime = new Date();
            addToConsole("RSA-2048 Key Generation = " + (endTime - startTime) + "ms");
            
            var bs = 1024 * 1024;
            var str = '';
            while ( str.length < bs ) str += chunk;
            str = str.substr( 0, bs );

            var buf = new Uint8Array(bs);
            for ( var i = 0; i < bs; i++ ) buf[i] = str.charCodeAt(i);
            
            var pubkey = [
                RSA2048Key[0],
                RSA2048Key[1]
            ];
            
            /*var privkey = [
                RSA2048Key[2],
                RSA2048Key[3],
                RSA2048Key[4],
                RSA2048Key[5],
                RSA2048Key[6],
                RSA2048Key[7]
            ];*/
            
            startTime = new Date();
            var text = "Hello World!";
            var cipherText = asmCrypto.RSA_OAEP_SHA256.encrypt( text, pubkey );
            endTime = new Date();
            addToConsole("Encryption = " + (endTime - startTime) + "ms");
            
            startTime = new Date();
            var plainText = asmCrypto.RSA_OAEP_SHA256.decrypt( cipherText, RSA2048Key );
            endTime = new Date();
            addToConsole("Decryption = " + (endTime - startTime) + "ms");
            //window.alert(asmCrypto.bytes_to_string(plainText));
        }
        
        /* Times out on desktop browser, crashes everything... do not run...
        function asmcryptoRSA15360Test()
        {
            startTime = new Date();
            var RSA15360Key = asmCrypto.RSA.generateKey(15360, 65537);
            endTime = new Date();
            addToConsole("RSA-15360 Key Generation = " + (endTime - startTime) + "ms");
        }*/
        
        function startTests() {
            addToConsole("!! asmcryptoTests !! ");
            asmcryptoAES128Test();
            asmcryptoAES256Test();
            
            asmcryptoRSA2048Test(); //not even equivalent security to 128-bit, more like 112-bit AES http://i.cmpnet.com/commsdesign/csd/2004/mar04/certicom-table3.jpg
            
            asmcryptoRSA3072Test();
            //asmcryptoRSA15360Test();

            //addToConsole("asmcryptoTest AES-128-ECB Time Taken = " + (endTime - startTime) + "ms");
            //var cihper = CryptoJS.AES.encrypt( str, cryptojs_key, { iv: cryptojs_key } );
        }
		
		
		function WebCryptoSHATest(digestName)
		{
			var timeTaken = 0;
			var startTime = new Date();
			window.crypto.subtle.digest(
				{
					name: digestName,
				},
				new Uint8Array([1,2,3,4]) //The data you want to hash as an ArrayBuffer
			).then(function(hash){
				//returns the hash as an ArrayBuffer
				console.log(new Uint8Array(hash));
			});
			//returns the hash as an ArrayBuffer
			endTime = new Date();
			timeTaken = (endTime - startTime);
			return timeTaken;			
		}
		
		function startHashTests() {
			numTests = 100000;
		
			var totalTime = 0;
			for (i = 0; i < numTests; i++) {
				totalTime += WebCryptoSHATest("SHA-1");
			}
			addToConsole("SHA-1" + " = " + (totalTime/numTests) + "ms");
			
			totalTime = 0;
			for (i = 0; i < numTests; i++) {
				totalTime += WebCryptoSHATest("SHA-256");
			}
			addToConsole("SHA-256" + " = " + (totalTime/numTests) + "ms");
			
			totalTime = 0;
			for (i = 0; i < numTests; i++) {
				totalTime += WebCryptoSHATest("SHA-384");
			}
			addToConsole("SHA-384" + " = " + (totalTime/numTests) + "ms");
			
			totalTime = 0;
			for (i = 0; i < numTests; i++) {
				totalTime += WebCryptoSHATest("SHA-512");
			}
			addToConsole("SHA-512" + " = " + (totalTime/numTests) + "ms");
		
			numTests = 10;
		}
		
		function ab2str(buf) {
		  return String.fromCharCode.apply(null, new Uint16Array(buf));
		}
        
        function startAESTests() {
		
			numTests = 10;
			
			var totalTimeAES = [0,0];
			for (i = 0; i < numTests; i++) {
				var temp = asmcryptoAES128Test();
				totalTimeAES[0] += temp.encryptionTimeTaken;
				totalTimeAES[1] += temp.decryptionTimeTaken;
			}
			addToConsole("ASMCrypto-AES-CBC-128-Encryption" + " = " + (totalTimeAES[0]/numTests) + "ms");
			addToConsole("ASMCrypto-AES-CBC-128-Decryption" + " = " + (totalTimeAES[1]/numTests) + "ms");
			
			totalTimeAES = [0,0];
			for (i = 0; i < numTests; i++) {
				var temp = asmcryptoAESGCM128Test();
				totalTimeAES[0] += temp.encryptionTimeTaken;
				totalTimeAES[1] += temp.decryptionTimeTaken;
			}
			addToConsole("ASMCrypto-AES-GCM-128-Encryption" + " = " + (totalTimeAES[0]/numTests) + "ms");
			addToConsole("ASMCrypto-AES-GCM-128-Decryption" + " = " + (totalTimeAES[1]/numTests) + "ms");
			
			/*totalTimeAES = [0,0];
			for (i = 0; i < numTests; i++) {
				var temp = asmcryptoAESCTR128Test();
				totalTimeAES[0] += temp.encryptionTimeTaken;
				totalTimeAES[1] += temp.decryptionTimeTaken;
			}
			addToConsole("ASMCrypto-AES-CTR-128-Encryption" + " = " + (totalTimeAES[0]/numTests) + "ms");
			addToConsole("ASMCrypto-AES-CTR-128-Decryption" + " = " + (totalTimeAES[1]/numTests) + "ms");*/
			
			totalTimeAES = [0,0];
			for (i = 0; i < numTests; i++) {
				var temp = asmcryptoAES256Test();
				totalTimeAES[0] += temp.encryptionTimeTaken;
				totalTimeAES[1] += temp.decryptionTimeTaken;
			}
			addToConsole("ASMCrypto-AES-CBC-256-Encryption" + " = " + (totalTimeAES[0]/numTests) + "ms");
			addToConsole("ASMCrypto-AES-CBC-256-Decryption" + " = " + (totalTimeAES[1]/numTests) + "ms");
			
			totalTimeAES = [0,0];
			for (i = 0; i < numTests; i++) {
				var temp = asmcryptoAESGCM256Test();
				totalTimeAES[0] += temp.encryptionTimeTaken;
				totalTimeAES[1] += temp.decryptionTimeTaken;
			}
			addToConsole("ASMCrypto-AES-GCM-256-Encryption" + " = " + (totalTimeAES[0]/numTests) + "ms");
			addToConsole("ASMCrypto-AES-GCM-256-Decryption" + " = " + (totalTimeAES[1]/numTests) + "ms");
			
			/*totalTimeAES = [0,0];
			for (i = 0; i < numTests; i++) {
				var temp = asmcryptoAESCTR256Test();
				totalTimeAES[0] += temp.encryptionTimeTaken;
				totalTimeAES[1] += temp.decryptionTimeTaken;
			}
			addToConsole("ASMCrypto-AES-CTR-256-Encryption" + " = " + (totalTimeAES[0]/numTests) + "ms");
			addToConsole("ASMCrypto-AES-CTR-256-Decryption" + " = " + (totalTimeAES[1]/numTests) + "ms");*/
			
			for (i = 0; i < numTests; i++) {
				WebCryptoAESGCMTest(128, i);
			}
			for (i = 0; i < numTests; i++) {
				WebCryptoAESGCMTest(256, i);
			}
			
			for (i = 0; i < numTests; i++) {
				WebCryptoAESCTRTest(128, i);
			}
			for (i = 0; i < numTests; i++) {
				WebCryptoAESCTRTest(256, i);
			}
			
			for (i = 0; i < numTests; i++) {
				WebCryptoAESCBCTest(128, i);
			}
			for (i = 0; i < numTests; i++) {
				WebCryptoAESCBCTest(256, i);
			}
			
        }
        
        function startRSATests() {
            addToConsole("!! asmcryptoTests !! ");
			for (i = 0; i < numTests; i++) {
				asmcryptoRSA2048Test();
			}
        }

        function create()
        {
            var inputData = new Uint8Array(4 * (height * width));
            /*for (var i = 0; i < height * width; i++)
            {
                inputData[i] = generateRandomNumber();
            }
            for (var i = 0; i < 5; i++)
            {
                console.log(inputData[i]);
            }*/

            var attributes = {  
                aPosition: { type: 'v3', value: new THREE.Vector3() }
              };
              
            //var material_FS = shaderMaterial(uniform(inputData), document.getElementById('vertexShader').textContent, document.getElementById('demoFragmentShader1').textContent);
            var material_FS = shaderMaterial(uniform(inputData), document.getElementById('vertexShader').textContent, document.getElementById('randomNumberGeneratorFragmentShader').textContent);

            /*var material_FS = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader1').textContent
            });*/

            var mesh = new THREE.Mesh(geometry, material_FS);
            scene.add(mesh);

            var myTexture = new THREE.WebGLRenderTarget( height, width, renderTargetParams() );

            renderer.render(scene, camera, myTexture, true);

            /*var uniforms2 = {
                sTexture: { type: "t", value: myTexture },
                sTexture2: { type: "t", value: dataTexture }
            };*/
            
            //var material = shaderMaterial(uniforms2, document.getElementById('vertexShader').textContent, document.getElementById('fragmentShader2').textContent);

            /*var material = new THREE.ShaderMaterial({
                uniforms: uniforms2,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader2').textContent
            });*/

            //var mesh2 = new THREE.Mesh(geometry, material);
            //scene2.add(mesh2);
        }
        
        
        var render = function () {
            requestAnimationFrame(render);
            //create();
            renderer.render(scene, camera);
            endTime = new Date();
        }

        </script>
        <div class="logging" id="logging"></div>
        <script>
            initLogging();
            //addToConsole("Random Number = " + generateRandomNumber());
            addButtonsToConsole("<input type=\"submit\" onclick=\"start();\" value=\"Start GPU Tests\" />");
            addButtonsToConsole(" <input type=\"submit\" onclick=\"startTests();\" value=\"Start CPU Tests\" />");
            addButtonsToConsole(" <input type=\"submit\" onclick=\"startAESTests();\" value=\"Start AES Tests\" />");
            addButtonsToConsole(" <input type=\"submit\" onclick=\"startRSATests();\" value=\"Start RSA Tests\" />");
			addButtonsToConsole(" <input type=\"submit\" onclick=\"startECCTests();\" value=\"Start ECC Tests\" />");
			addButtonsToConsole(" <input type=\"submit\" onclick=\"startHashTests();\" value=\"Start Hash Tests\" />");
			addButtonsToConsole(" <input type=\"submit\" onclick=\"startWorker();\" value=\"Start Web Worker\" />");
			addButtonsToConsole(" <input type=\"submit\" onclick=\"stopWorker();\" value=\"Start Web Worker\" />");
            addButtonsToConsole(" <output id=\"result\"></output> ");
        </script>

	<script>
	var w;

	function startWorker() {
	    if(typeof(Worker) !== "undefined") {
		if(typeof(w) == "undefined") {
		    w = new Worker("js/demo_workers.js");
		}
		w.onmessage = function(event) {
		    document.getElementById("result").innerHTML = event.data;
		};
	    } else {
		document.getElementById("result").innerHTML = "Sorry! No Web Worker support.";
	    }
	}

	function stopWorker() {
	    w.terminate();
	    w = undefined;
	}
	</script>
    </body>
</html>
